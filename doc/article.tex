\documentclass[a4paper,11pt]{article}
\usepackage{url}
%\usepackage{fullpage}

%opening
\title{UNIX Shell Filters for Newick Trees}
\author{Thomas Junier}

\newcommand{\cli}{\textsc{CLI}}
\newcommand{\gui}{\textsc{GUI}}
\newcommand{\unix}{Unix}
\newcommand{\prog}[1]{\texttt{nw\_#1}}

\begin{document}

\maketitle

\begin{abstract}
The Newick Utilities are a set of UNIX command-line programs for working with
Newick-formatted phylogenetic trees. The motivation for writing them is that we did not find any open-source programs with equivalent functionality and a noninteractive, filter interface. [\ldots]
\end{abstract}

\textit{\noindent{} [Intended readership: bioinformaticians with interest/experience in phylogeny and working with the UNIX shell, especially on large data sets. Reader is assumed to have some idea of: phylogenies, Unix, shells (interactive and scripts).]
[Questions: what would be the best journal to send this to? Instructions to authors permitting, should there be more examples?]}
 
\section*{Introduction}

Some applications in phylogeny involve large numbers of trees. Bootstrapping is an obvious example, but others exist, like bootscanning (sliding a window over an alignment and computing a tree at each window position), or (say) evolutionary analysis of all 1:1 orthologs of a given clade. The trees need to be produced, and then must be processed, involving steps like rerooting, extracting branch lengths, attributing support values, extracting support values, extracting subtrees, etc. Due to the large number of trees, it is highly desirable that the processing steps be automated (if only because humans will get bored by repetitive tasks and will commit more errors as the amount of data grows).

There is a large choice of programs for manipulating trees (e.g.
NJPlot or TreeView, more examples at \url{
http://evolution.genetics.washington.edu/phylip/software.html}). Most have an interactive, graphical interface (\gui{}). The advantages and drawbacks of interactive interfaces have been disputed for decades; let us just remark that any program that requires user interaction is hard to integrate into a larger application, so it is difficult to automate tree processing using interactive tools.

Automation is also facilitated by good interoperation between the programs involved. The ability to read data from standard input and write results on standard output is one way of improving interoperation in a \unix{} shell environment. \cite{Gancarz2002}. programs that have these properties are known as \textit{filters}.

Faced with the need to handle large or numerous trees in automated pipelines, and having found nothing on the Internet that met our needs, we designed and wrote
a collection of programs that require no user interaction, work with any number of trees of any size, and behave as filters. The functions needed are shown in table \ref{tab:NU_func}.

\begin{table*}
\begin{tabular}{lp{0.75\textwidth}}
Program & Function \\ 
\hline 
\prog{reroot} & reroot trees on outgroup, specified by labels \\
\prog{clade} & extract subtrees defined by labels \\
\prog{distance} & extract branch lengths in various ways (from root, from parent, as matrix, etc.) \\
\prog{labels} & extract labels (leaf, inner nodes, or both) \\
\prog{support} & attribute support values to a known tree based on bootstrap replicates \\
\prog{rename} & rename node labels based on a mapping \\
\prog{order} & order tree nodes (without changing topology) \\
\prog{topology} & extract topological information (by discarding branch length data, etc) \\
\prog{condense} & simplify trees (e.g. whole clades of the same label) \\
\prog{prune} & discard nodes by label \\
 \ldots & [maybe keep only the most interesting] \\
\hline
\end{tabular}
\caption{The Newick Utilities and their functions}
\label{tab:NU_func}
\end{table*}

To help work in the shell, a program for displaying tree graphs as text was added to the list (it can also output SVG).

\section*{Results}

The Newick Utilities perform the functions listed in table \ref{tab:NU_func} and have the following properties:

\begin{itemize}
 \item one program for one function
 \item input format is Newick, no arbitrary limit on the number or size og the input trees
 \item all output is text; those programs which output trees output Newick
 \item no interaction required
 \item data are read from a file or from standard input; results are written to standard output
 \item all options are passed on the command line (no control files)
 \item self-documenting (option \texttt{-h})
\end{itemize}

\subsection*{Implementation}

The programs are written in C and use the \textsc{GNU} autotools as a build tool. They are known to compile on various distributions of Linux, as well as on MacOS X.

\subsection*{Performance}

While performance was not the absolute priority (we tried to keep code simple and avoid fancy algorithms where possible), the programs perform reasonably well. For example, rerooting 500 trees of 35 species takes about 8 ms on an Intel Core Duo [\textit{more specs}] running Linux ($N = 100$).

\section*{Examples}

\subsection*{PCA of Branch Lengths}

Suppose we are interested in the evolution rates of about one thousand 1:1 orthologs from 7 tetrapod species. We produce the $\sim$ 1,000 maximum-likelihood trees, and we want to submit the branch lengths to principal components analysis (\textsc{PCA}). Suppose further that we used three ``fishes'', \textit{Fugu}, \textit{Tetraodon} and \textit{Danio}, as outgroup. Finally, say the trees are in a file named \texttt{vertebrata.txt}. The steps involved are:
\begin{enumerate}
 \item reroot all the trees on the ``fishes'' -- ML trees are unrooted
 \item extract the branch lengths for all tetrapods, from their last common ancestor to the tip
\end{enumerate}
This can be done in the following way (edited to fit page width):

\begin{verbatim}
$ nw_reroot vertebrata.txt Danio Fugu Tetraodon | 
nw_distance -t -m lca - Xenopus Gallus Monodelphis
Bos Canis Mus Homo 
\end{verbatim}

The first program, \prog{reroot}, reads in all the trees in \texttt{vertebrata.txt} and reroots them on the clade defined by the ``fishes''. The result is written on standard output, which is piped into the second program, \prog{distance}. For each (rerooted) tree, this program finds the last common ancestor of all tetrapods (\textit{Xenopus} to \textit{Homo}), and prints out the length from that node to each of the tetrapod tips, on one line. The result is a rectangular matrix of 10 columns and 1000 lines, suitable for \textsc{PCA}.

\subsection*{Bootscanning}

In a sliding-window experiment, we have computed a tree for each window over an alignment. We want to extract the tree topology for each window. Say file \texttt{win\_trees.txt} contains the trees, ordered by window position. We need the following steps for each tree:
\begin{enumerate}
 \item reroot the tree
 \item order the tree (folds all equivalent topologies into the same Newick string)
 \item discard irrelevant branch length and internal label information
\end{enumerate}
This can be done like this:
\begin{verbatim}
$ nw_reroot win_trees Out | nw_order - | nw_topology -I -
\end{verbatim}
where \verb|Out| is the label of the outgroup.


\section*{Discussion}

In our opinion, one of the most useful features of Unix shells is the ability to  ``glue'' arbitrary programs together in pipelines or shell scripts. This is (partly) because research is sufficiently unpredictable for any specialized tool to be confronted, sooner or later, with a problem it wasn't designed for. We found that the ``Unix Philosophy'' tenets of i) making every program a filter, ii) making every program do one thing well, and iii) avoiding captive interfaces work well in practice, and we designed the Newick Utilities with these guidelines in mind (whether we succeeded is another matter).

\bibliographystyle{plain} 
\bibliography{article}


\end{document}
