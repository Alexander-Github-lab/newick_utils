\documentclass[a4paper,11pt]{article}
\usepackage{url}
%\usepackage{fullpage}

%opening
\title{UNIX Shell Filters for Newick Trees}
\author{Thomas Junier and Evgeny Zdobnov}

\newcommand{\cli}{\textsc{CLI}}
\newcommand{\gui}{\textsc{GUI}}
\newcommand{\unix}{Unix}
\newcommand{\prog}[1]{\texttt{nw\_#1}}
\newcommand{\nutils}{Newick Utilities}

\begin{document}

\maketitle

\begin{abstract}
The Newick Utilities are a set of UNIX command-line programs for working with
Newick-formatted phylogenetic trees. The motivation for writing them is that we did not find any open-source programs with equivalent functionality and a noninteractive, filter interface.
\end{abstract}

\textit{\noindent{} [Intended readership: bioinformaticians with interest/experience in phylogeny and working with the UNIX shell, especially on large data sets. Reader is assumed to have some idea of: phylogenies, Unix, shells (interactive and scripts).]
[Questions: what would be the best journal to send this to? Instructions to authors permitting, should there be more examples?]}
 
\section*{Introduction}

Some applications in phylogeny involve large numbers of trees, or trees with large numbers of taxa. Bootstrapping is an obvious example, but others exist, like bootscanning \cite{Salminen1995}, or (say) evolutionary analysis of all 1:1 orthologs of a given clade. Once the trees have been constructed, they must often be processed, involving steps like (re)rooting, extracting branch lengths, computing support values, pruning, extracting subtrees, etc. Since human users are likely to commit more errors as the amount of  data grows, it is desirable that the whole process  be automated. This will typically be made in an analysis pipeline of some sort, possibly involving many programs.

The ease of automation will depend on the type of interface the programs offer. In general, it is harder to automate a program that requires user interaction than one that doesn't. The ability of a program to work on several input trees (rather than a single one) is also a plus.

All main methods for constructing trees have command-line implementations (\textit{e.g.}, PhyML \cite{Guindon2003}, BioNJ \cite{Gascuel1997}, etc), these lend themselves well to automation. 
The situation is different for tree processing. Although there is a large choice of programs for manipulating trees (e.g.
NJplot \cite{Perri√®re1996} or TreeView \cite{Page2002}), most have an interactive, graphical interface, which is hard or impossible to automate.

Automation is also facilitated by good interoperation between the programs involved, when there is more than one. The ability to read data from standard input and write results on standard output is one way of providing this in a \unix{} shell environment. Programs that have these properties are termed \textit{filters}.

Faced with the need to handle large or numerous trees in automated pipelines, and having failed to find any software that met our needs, we designed and wrote a collection of filters that perform a range of frequently used tree operations, require no user interaction, and work with any number of trees of any size. 

\begin{table*}
\begin{tabular}{lp{0.75\textwidth}}
Program & Function \\ 
\hline 
\prog{reroot} & reroot trees on outgroup, specified by labels \\
\prog{clade} & extract subtrees defined by labels \\
\prog{distance} & extract branch lengths in various ways (from root, from parent, as matrix, etc.) \\
\prog{labels} & extract labels (leaf, inner nodes, or both) \\
\prog{support} & attribute support values to a known tree based on bootstrap replicates \\
\prog{rename} & rename node labels based on a mapping \\
\prog{order} & order tree nodes (without changing topology) \\
\prog{topology} & extract topological information (by discarding branch length data, etc) \\
\prog{condense} & simplify trees (e.g. whole clades of the same label) \\
\prog{prune} & discard nodes by label \\
 \ldots & [maybe keep only the most interesting] \\
\hline
\end{tabular}
\caption{Selected programs from the Newick Utilities}
\label{tab:NU_func}
\end{table*}



\section*{Results}

The \nutils{} perform the functions listed in table \ref{tab:NU_func}. The programs have the following common properties:

\begin{itemize}
 \item one program for one function
 \item input format is Newick, no arbitrary limit on the number or size of the input trees
 \item all output is text; those programs which output trees output Newick
 \item no interaction required
 \item data are read from a file or from standard input; results are written to standard output
 \item all options are passed on the command line (no control files)
 \item self-documenting (option \texttt{-h})
\end{itemize}

\subsection*{Implementation}

The programs are written in C and use the \textsc{GNU} autotools as a build tool.

\subsection*{Performance}

While performance was not the absolute priority (we tried to keep code simple and avoid fancy algorithms where possible), the programs perform reasonably well. For example, rerooting 500 trees of 35 species takes about 8 ms on an Intel Core Duo [\textit{more specs}] running Linux ($N = 100$).

\section*{Examples}

\subsection*{Principal Components Analysis of Branch Lengths}

Suppose we are interested in the evolution rates of about one thousand 1:1 orthologs from 7 tetrapod species. We produce the $\sim$ 1,000 maximum-likelihood trees, and we want to submit the branch lengths to \textsc{PCA}. Suppose further that we used three ``fishes'', \textit{Fugu}, \textit{Tetraodon} and \textit{Danio}, as outgroup. Finally, say the trees are in a file named \texttt{vertebrata.txt}. The steps involved are:
\begin{enumerate}
 \item reroot all the trees on the ``fishes'' -- ML trees are unrooted
 \item extract the branch lengths for all tetrapods, from their last common ancestor to the tip
\end{enumerate}
This can be done in the following way (edited to fit page width):

\begin{verbatim}
$ nw_reroot vertebrata.txt Danio Fugu Tetraodon | 
nw_distance -t -m lca - Xenopus Gallus Monodelphis
Bos Canis Mus Homo 
\end{verbatim}

The first program, \prog{reroot}, reads in all the trees in \texttt{vertebrata.txt} and reroots them on the clade defined by the ``fishes''. The result is written on standard output, which is piped into the second program, \prog{distance}. For each (rerooted) tree, this program finds the last common ancestor of all tetrapods (\textit{Xenopus} to \textit{Homo}), and prints out the length from that node to each of the tetrapod tips, on one line. The result is a rectangular matrix of 10 columns and 1000 lines, suitable for \textsc{PCA}.

\subsection*{Bootscanning}

In a sliding-window experiment, we have computed a tree for each window over an alignment. We want to extract the tree topology for each window. Say file \texttt{win\_trees.txt} contains the trees, ordered by window position. We need the following steps for each tree:
\begin{enumerate}
 \item reroot the tree
 \item order the tree (folds all equivalent topologies into the same Newick string)
 \item discard irrelevant branch length and internal label information
\end{enumerate}
This can be done like this:
\begin{verbatim}
$ nw_reroot win_trees Out | nw_order - | nw_topology -I -
\end{verbatim}
where \verb|Out| is the label of the outgroup.

\subsection*{Research}

The Newick utilities have been used \textit{e.g.} in \cite{Tapparel2007}. This study involved computing hundreds of maximum-likelihood trees, which was done with PhyML \cite{Guindon2003}. Rerooting, attribution of bootstrap support values, extraction of subtrees, and classification of topology were done with the \nutils{}.
\section*{Discussion}

In our opinion, one of the most useful features of Unix shells is the ability to  ``glue'' arbitrary programs together in pipelines or shell scripts. This is (partly) because research is sufficiently unpredictable for any specialized tool to be confronted, sooner or later, with a problem it wasn't designed for. We found that the ``Unix Philosophy'' tenets of i) making every program a filter, ii) making every program do one thing well, and iii) avoiding captive interfaces work well in practice, and we designed the Newick Utilities with these guidelines in mind.

\bibliographystyle{plain} 
\bibliography{article}


\end{document}
