
\section{Displaying Trees}
\label{sct_display}

Perhaps the simplest and most common operation on a \nw{} tree is just to look
at it. But a \nw{} tree is not very intuitive for us humans, as we can quickly
see by looking \eg{} at a tree of Old World primates:

\verbatiminput{display_12_txt.cmd}
\begin{samepage}
\verbatiminput{display_12_txt.out}
\end{samepage}

\noindent{}So we want to make a graphical representation from it. This is the purpose of
the \display{} program. 

\subsection{As Text}
\label{sct_display_text}

At its simplest, \display{} just outputs a text graph. Here is the primates tree, shown with \display{}:
\verbatiminput{display_1_txt.cmd}
\begin{samepage}
\verbatiminput{display_1_txt.out}
\end{samepage}
That's pretty low-tech compared to interactive, colorful graphical displays,
but if you use the shell a lot (like I do), you may find it useful.

You can use option \texttt{-w} to set the number of columns
available for display (the default is 80):

\verbatiminput{display_2_txt.cmd}
\begin{samepage}
\verbatiminput{display_2_txt.out}
\end{samepage}

\subsubsection{Scale Bar}

If the tree is a phylogram, \display{} prints a scale bar. Its units can be
specified with option \texttt{-u}, the default is substitutions per site. To
suppress the scale bar, pass the \texttt{-S} switch. The scale bar can also "go
backwards" (option \texttt{-t}), \ie{} the scale bar's zero is aligned with the
leaves and units increase towards the root. This is handy when the units are
ages, \eg{} in millions of years ago, but it only makes much sense if the leaves
themselves are aligned. See \ref{sct_duration} for an example.

\subsubsection{Placement of Inner Node Labels}

Option \texttt{-I} controls the placement of inner node labels. It takes an
argument, which can be \texttt{l} (lowercase l -- towards the leaves),
\texttt{m} (in the middle), or \texttt{r} (towards the root). The default
behaviour is \texttt{l}.  Here is the above tree, with inner labels near the
root:

\verbatiminput{display_14_txt.cmd}
\begin{samepage}
\verbatiminput{display_14_txt.out}
\end{samepage}

\subsection[As SVG]{As Scalable Vector Graphics}
\label{sct_display_svg}

First, a disclaimer: there are dozens of tools for viewing trees out there, and
I'm not interested in competing with them. The reasons why I included \svg{}
capabilities (besides automation, etc.) were:
\begin{itemize}
\item I wanted to be able to produce reasonably good graphics even if no other
tool was at hand
\item I wanted to be sure that large trees could be rendered\footnote{I have
had serious problems visualising trees of more than 1,000 leaves using some
popular software I will not name here - either it was painfully slow, or it
simply crashed, or else the output was unreadable, incomplete, or otherwise
unsuitable.}
\end{itemize}
To produce \svg, pass option \texttt{-s}:
\begin{verbatim}
$ nw_display -s catarrhini > catarrhini.svg
\end{verbatim}
Now you can visualize the result using any \svg-enabled tool (all good Web
browsers can do it), or convert it to another format with, say \texttt{rsvg} or
Inkscape (\url{http://www.inkscape.org}).  The \svg{} produced by \display{} is
designed to be easy to edit in an interactive editor (Inkscape, Adobe
Illustrator, etc.): for example, the tree edges are in one group, and the text
in another, so it is easy to change the line width of the edges, or the font
family of the text (you can also do this from \display{} using a \css{} map,
see \ref{sct_display_svg_css}).

The following \pdf{} image was produced like this:

\begin{verbatim}
$ inkscape -f catarrhini.svg -A catarrhini.pdf
\end{verbatim}

\begin{center}
 \includegraphics{display_3_svg.pdf}
\end{center}
All \svg{} images shown in this tutorial were processed in the same way. In the
rest of the document we will usually skip the redirection into an \svg{} file
and omit the \svg{}-to-\textsc{pdf} conversion step.

\subsubsection{Text-mode options}

Options for \ascii{} trees also work for \svg{}: \texttt{-S} suppresses the
scale bar\footnote{The positioning of the scale bar is a bit crude in \svg{}
mode, especially for radial trees. This is mainly because of the "\svg{} string
length curse", that is, the impossibility of finding out the length of a text
string in \svg.  This means it is hard to ensure the scale bar will not overlap
with a node label, unless one places it far away in a corner, which is what I do
for now. An improvement to this is on my TODO list.}, and \texttt{-u} specifies
its units; \texttt{-w} governs the tree's width, except that for \svg{} the
value is in pixels instead of columns; \texttt{-I} controls the placement of inner node
labels. 

\subsubsection{Radial trees}

You can make radial trees by passing the \texttt{-r} switch:
\verbatiminput{display_4_svg.cmd}
\begin{center}
\includegraphics{display_4_svg.pdf}
\end{center}

\subsubsection{Using CSS}
\label{sct_display_svg_css}

You can modify node style using \css. This is done by specifying a
\textit{\css{} map}, which is just a text file that says which style should be
applied to which node. If file \texttt{css.map} contains the following
\begin{quote}
\verbatiminput{css.map}
\end{quote} we can apply the style map to
the tree above by passing \texttt{-c}, which takes the name of the \css{} file
as argument:

\verbatiminput{display_5_svg.cmd}
\begin{center}
 \includegraphics{display_5_svg.pdf}
\end{center}

The syntax of the \css{} map file is as follows:
\begin{itemize}
	\item A line that starts with a \texttt{\#} (hash) is a comment, and will be
	ignored, as will be any line that contains only whitespace (space and TAB),
	as well as empty lines.
	\item Each line describes one style and the set of nodes to which it applies.
	A line contains elements separated by whitespace (whitespace between quotes
	does not count). 
	\item The first element of the line is the style, and it is a snippet of
	\css{} code. 
	\item The second element states whether the following nodes are to be treated
	individually or as a clade. It is either \texttt{Clade} or
	\texttt{Individual} (which can be abbreviated to \texttt{C} or \texttt{I},
	respectively).
	\item The remaining element(s) are node labels and specify the nodes to which
	the style must be applied: if the second element was \texttt{Clade}, the
	program finds the last common ancestor of the nodes and applies the style to
	that node and all its descendants. If the second element was
	\texttt{Individual}, then the style is only applied to the nodes themselves.
\end{itemize}

\noindent{}In our example, \texttt{css.map}:
\begin{itemize}
	\item the first line states that the style \texttt{stroke:red} must be applied
		to the \texttt{Clade} defined by \texttt{Macaca} and
		\texttt{Cercopithecus}, which consists of these two nodes, their ancestor
		\texttt{Cercopithecinae}, and \texttt{Papio}. 
	\item Line 2 prescribes that style \texttt{stroke:\#fa7} (an \svg{}
		hexadecimal color specification) must be applied to the clade defined by
		\texttt{Homo} and \texttt{Hylobates}, which consists of these two nodes,
		their last common ancestor (unlabeled), and all its descendants (that is,
		\texttt{Homo}, \texttt{Pan}, \texttt{Gorilla}, \texttt{Pongo}, and
		\texttt{Hylobates}, as well as the inner nodes \texttt{Hominini},
		\texttt{Homininae} and \texttt{Hominidae}). 
	\item Line 3 instructs that the style \texttt{stroke:green} be applied
		individually to nodes \texttt{Colobus} and \texttt{Cercopithecus}, and only
		these nodes - not to the clade that they define.  
	\item Line 4 says that style \texttt{stroke-width:2;~stroke:blue} should be
		applied to the clade defined by \texttt{Homo} and \texttt{Pan} - note that
		the quotes have been removed: they are not part of the style, rather they
		allow us to improve readability by adding some whitespace.
\end{itemize}

The style of an inner clade overrides that of an outer clade, \textit{e.g.},
although the \texttt{Homo} - \texttt{Pan} clade is nested inside the
\texttt{Homo} - \texttt{Hylobates} clade, it has its own style (blue, wide
lines) which overrides the containing clade's style (pinkish with normal
width).  Likewise, \texttt{Individual} overrides \texttt{Clade}, which is why
\texttt{Cercopithecus} is green even though it belongs to a "red" clade.

\bigskip

Styles can also be applied to labels. Option \texttt{-l} (lowercase l) specifies
the leaf label style, option \texttt{-i} the inner node label style, and option
\texttt{-b} the branch length style. For example, the following tree, which was
produced using defaults, could be improved a bit:

\verbatiminput{display_6_svg.cmd}
\begin{center}
  \includegraphics{display_6_svg.pdf}
\end{center}

\noindent{}Let's remove the branch length labels, reduce
the vertical spacing, reduce the size of inner node labels (bootstrap values),
and write the leaf labels in italics, using a font with serifs:

\verbatiminput{display_7_svg.cmd}
\begin{center}
  \includegraphics{display_7_svg.pdf}
\end{center}

\noindent{}Still not perfect, but much better. Option \texttt{-v} specifies the
vertical spacing, in pixels, between two successive leaves (the default is 40).
Option \texttt{-b} sets the style of branch labels, option \texttt{-l} sets the
style of leaf labels, and option \texttt{-i} sets the style of inner node
labels. Note that we did not \emph{discard} the branch lengths (we could do
this with \topology), because doing so would reduce the tree to a cladogram.
Instead, we set their \css{} style to \texttt{opacity:0}
(\texttt{visibility:hidden} also works).

What if we want to change the default style? Say we want the branches in blue,
and two pixels wide? That's option \texttt{-d}:

\verbatiminput{display_13_svg.cmd}
\begin{center}
  \includegraphics{display_13_svg.pdf}
\end{center}

\subsection{Ornaments}

Ornaments are arbitrary snippets of \svg{} code that are displayed at specified
node positions. Like \css, this is done with a map. The ornament map has the
same syntax as the \css{} map, except that you specify \svg{} elements rather
than \css{} styles. The \texttt{Individual} keyword means that all nodes named
on a given line sport the corresponding ornament, while \texttt{Clade} means
that only the clade's \lca{} must be adorned. The ornament is translated in
such a way that its (0,0) coordinate corresponds to the position of the node.
In radial graphs, text ornaments are rotated like node labels.

The following file, \texttt{ornament.map}, instructs to draw a red circle with
a black border on \texttt{Homo} and \texttt{Pan}, and a cyan circle with a blue
border on the root of the \texttt{Homo} - \texttt{Hylobates} clade.
\texttt{Gorilla} node will be annotated with the word "plains", and
\texttt{Pongo} with "Borneo" in italics\footnote{In fact, to annotate that these
are the Western gorilla and the Borneo orang-utan, it would be simpler just to
label the corresponding leaves accordingly, \ie, \texttt{Gorilla\_gorilla} and
\texttt{Pongo\_pygmaeus}. But this is just an example\ldots}. The \svg{}
is enclosed in double quotes because it contains spaces - note that single
quotes are used for the values of \xml{} attributes. The ornament map is
specified with option \texttt{-o}:
\begin{quote}
 \verbatiminput{ornament.map}
\end{quote}
\verbatiminput{display_8_svg.cmd}
\begin{center}
 \includegraphics{display_8_svg.pdf}
\end{center}

\noindent{}Text ornaments are special: they follow the node's parent edge, and are aligned
with the edge's tip. In radial trees, this means that they are rotated like
regular node labels.  Ornaments and \css{} can be combined:

\verbatiminput{display_9_svg.cmd}
\begin{center}
 \includegraphics{display_9_svg.pdf}
\end{center}

\subsubsection{Example: Mapping GC Content}
\label{sct_display_ornament_xpl_gc}

In a study of human rhinoviruses, I have produced a phylogenetic tree,
\texttt{HRV\_ingrp.nw}. I have also computed the \gc{} content of the sequences,
and mapped it into a gradient that goes from {\color{Blue} blue} (33.3\%) to
{\color{Red} red} (44.5\%). I used this gradient to produce a \css{} map,
\texttt{b2r.map}:

\verbatiminput{display_11_txt.cmd}
\verbatiminput{display_11_txt.out}

\noindent{}in which the \texttt{fill} values are hexadecimal color codes along
the gradient. Then:

\verbatiminput{display_10_svg.cmd}
\includegraphics{display_10_svg.pdf}
\bigskip{}

\noindent{}As we can see, the high-\gc{} sequences are all found in the same
main clade.

\subsubsection{Multiple SVG Trees}

Like all \nutils, \display{} can handle multiple trees, even in \svg{} mode.
The best way to do this was not evident: one can generate one file per tree (but
then we break the rule that every program is a filter and so writes to standard
output), or one can put all the trees in one \svg{} document (but then we have
to impose tiling or some other arrangement), or one can just output one \svg{}
document after another. This is what we do (this may change in the future). So
if you have many trees in document \texttt{forest.nw}, you can say:
\begin{quote}
\verb+$ nw_display -s forest.nw > forest_svg+
\end{quote}
But \texttt{forest\_svg} isn't valid \svg{} -- it is a concatenation of many \svg{} documents. You can just extract them into individual files with \texttt{csplit}:
\begin{quote}
\verb+$ csplit -sz -f tree_ -b '%02d.svg' forest_svg '/<?xml/' {*}+
\end{quote}
This will produce one \svg{} file per tree in \texttt{forest.nw}, named \texttt{tree\_01.svg}, \texttt{tree\_02.svg}, etc.

\subsubsection{\display{} \texttt{-s} stores its arguments}

When run in \svg{} mode, \display{} "remembers" its arguments, that is, it puts
them in an \xml{} comment with the keyword \texttt{arguments}. It is then
trivial to retrieve them:

\verbatiminput{display_15_txt.cmd}
\verbatiminput{display_16_txt.cmd}
\verbatiminput{display_16_txt.out}

\noindent{}This is handy when one wants to re-use a set of options on another
tree, especially after a while when one doesn't remember the exact values of the
parameters, or which was the input tree, etc. 

\subsection{Options not Covered}

\display{} has many options, and we will not describe them all here - all of
them are described when you pass option \texttt{-h}. They include support for
clickable images (with URLs to arbitrary Web pages), nudging labels, changing
the root length, etc. 
